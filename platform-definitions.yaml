---

- name: C#
  ext: cs
  template: |
    {%- if product_url is defined %}
    /* {{product_url}} */

    {% endif -%}
    using System;
    using System.IO;
    using System.Collections.Generic;

    public class DecentlabDecoder
    {
      private delegate double conversion(double[] x);

      private class Sensor
      {
        internal int length { get; set; }
        internal List<SensorValue> values { get; set; }
        internal Sensor(int length, List<SensorValue> values)
        {
          this.length = length;
          this.values = values;
        }
      }

      private class SensorValue
      {
        internal string name { get; set; }
        internal string unit { get; set; }
        internal conversion convert;
        internal SensorValue(string name, string unit, conversion convert)
        {
          this.name = name;
          this.unit = unit;
          this.convert = convert;
        }
      }

      private static readonly List<Sensor> SENSORS = new List<Sensor>() {
      {%- for sensor in sensors %}
        new Sensor({{sensor.length}}, new List<SensorValue>() {
        {%- for value in sensor['values'] %}
          new SensorValue("{{value.name}}", {{'"%s"' | format(value.unit) if 'unit' in value else 'null'}}, {{'x => %s' | format(value.conversion | regex_replace('x(\d+)', 'x[\\1]') | regex_replace('([^\w]|^|)max\s*\(', '\\1Math.Max(') | regex_replace('([^\w]|^|)pow\s*\(', '\\1Math.Pow(')) if 'conversion' in value else 'null'}}){{'' if loop.last else ','}}
        {%- endfor %}
        }){{'' if loop.last else ','}}
      {%- endfor %}
      };

      private static int ReadInt(Stream stream)
      {
        return (stream.ReadByte() << 8) + stream.ReadByte();
      }


      public static Dictionary<string, Tuple<double, string>> Decode(byte[] msg)
      {
        return Decode(new MemoryStream(msg));
      }

      public static Dictionary<string, Tuple<double, string>> Decode(String msg)
      {
        byte[] output = new byte[msg.Length / 2];
        for (int i = 0, j = 0; i < msg.Length; i += 2, j++)
        {
          output[j] = (byte)int.Parse(msg.Substring(i, 2), System.Globalization.NumberStyles.HexNumber);
        }
        return Decode(output);
      }

      public static Dictionary<string, Tuple<double, string>> Decode(Stream msg)
      {
        var version = msg.ReadByte();
        if (version != 2)
        {
          throw new InvalidDataException("protocol version " + version + " doesn't match v2");
        }

        var result = new Dictionary<string, Tuple<double, string>>();
        result["Protocol version"] = new Tuple<double, string>(version, null);

        var deviceId = ReadInt(msg);
        result["Device ID"] = new Tuple<double, string>(deviceId, null);

        var flags = ReadInt(msg);
        foreach (var sensor in SENSORS)
        {
          if ((flags & 1) == 1)
          {
            double[] x = new double[sensor.length];
            for (int i = 0; i < sensor.length; i++)
            {
              x[i] = ReadInt(msg);
            }
            foreach (var val in sensor.values)
            {
              if (val.convert != null)
              {
                result[val.name] = new Tuple<double, string>(val.convert(x), val.unit);
              }
            }
          }
          flags >>= 1;
        }

        return result;
      }
    }
    {% if test_payloads is defined -%}
    public class Program
    {
      public static void Main()
      {
        var payloads = new string[] {
        {%- for pl in test_payloads %}
          "{{pl}}"{{'' if loop.last else ','}}
        {%- endfor %}
        };

        foreach (var pl in payloads)
        {
          var decoded = DecentlabDecoder.Decode(pl);
          foreach (var k in decoded.Keys)
          {
            Console.WriteLine(k + ": " + decoded[k]);
          }
          Console.WriteLine();
        }
      }
    }
    {% endif %}


- name: JavaScript
  ext: js
  template: |
    {%- if product_url is defined -%}
    /* {{product_url}} */

    {% endif -%}
    var decentlab_decoder = {
      SENSORS: [
      {%- for sensor in sensors %}
        {length: {{sensor.length}},
         values: [
        {%- for value in sensor['values'] -%}
                  {name: '{{value.name}}'
                  {%- if 'conversion' in value -%},
                   convert: function (x) { return {{value.conversion | regex_replace('x(\d+)', 'x[\\1]') | regex_replace('([^\w]|^|)max\s*\(', '\\1Math.max(') | regex_replace('([^\w]|^|)pow\s*\(', '\\1Math.pow(')}}; }
                  {%- endif %}
                  {%- if 'unit' in value -%},
                   unit: '{{value.unit}}'
                  {%- endif -%}
                  }
                  {%- if not loop.last -%},
                  {% endif -%}
        {%- endfor -%}]}{{'' if loop.last else ','}}
      {%- endfor %}
      ],

      read_int: function (bytes) {
        return (bytes.shift() << 8) + bytes.shift();
      },

      decode: function (msg) {
        var bytes = msg;
        var i, j;
        if (typeof msg === 'string') {
          bytes = [];
          for (i = 0; i < msg.length; i += 2) {
            bytes.push(parseInt(msg.substring(i, i + 2), 16));
          }
        }

        var version = bytes.shift();
        if (version != 2) {
          return {error: "protocol version " + version + " doesn't match v2"};
        }

        var deviceId = this.read_int(bytes);
        var flags = this.read_int(bytes);
        var result = {'Protocol version': version, 'Device ID': deviceId};
        // decode payload
        for (i = 0; i < this.SENSORS.length; i++, flags >>= 1) {
          if ((flags & 1) !== 1)
            continue;

          var sensor = this.SENSORS[i];
          var x = [];
          // convert data to 16-bit integer array
          for (j = 0; j < sensor.length; j++) {
            x.push(this.read_int(bytes));
          }

          // decode sensor values
          for (j = 0; j < sensor.values.length; j++) {
            var value = sensor.values[j];
            if ('convert' in value) {
              result[value.name] = {value: value.convert(x),
                                    unit: value.unit};
            }
          }
        }
        return result;
      }
    };
    {% if test_payloads is defined %}
    function main() {
    {%- for pl in test_payloads %}
      console.log(decentlab_decoder.decode("{{pl}}"));
    {%- endfor %}
    }

    main();
    {% endif %}

- name: Python
  ext: py
  template: |
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    {%- if product_url is defined %}
    # {{product_url}}

    {% endif -%}

    import logging
    import os
    import struct
    from base64 import binascii
    import json


    SENSORS = [
        {%- for sensor in sensors %}
        {'length': {{sensor.length}},
         'values': [{%- for value in sensor['values'] -%}
                    {'name': '{{value.name}}'
                    {%- if 'conversion' in value -%},
                     'convert': lambda x: {{value.conversion | regex_replace('x(\d+)', 'x[\\1]')}}
                    {%- endif %}
                    {%- if 'unit' in value -%},
                     'unit': '{{value.unit}}'
                    {%- endif -%}
                    }
                    {%- if not loop.last -%},
                    {% endif -%}
                    {%- endfor -%}]}{{'' if loop.last else ','}}
        {%- endfor %}
    ]


    def decode(msg):
        """msg: payload as one of hex string, list, or bytearray"""
        bytes_ = (binascii.a2b_hex(msg)
                  if isinstance(msg, str)
                  else bytearray(msg)
                       if isinstance(msg, list)
                       else msg)

        if bytes_[0] != 2:
            raise ValueError("protocol version {} doesn't match v2".format(bytes_[0]))

        devid = struct.unpack('>H', bytes_[1:3])[0]
        bin_flags = bin(struct.unpack('>H', bytes_[3:5])[0])
        flags = bin_flags[2:].zfill(struct.calcsize('>H') * 8)[::-1]

        words = [struct.unpack('>H', bytes_[i:i + 2])[0]
                 for i
                 in range(5, len(bytes_), 2)]

        cur = 0
        result = {}
        for flag, sensor in zip(flags, SENSORS):
            if flag != '1':
                continue

            x = words[cur:cur + sensor["length"]]
            cur += sensor["length"]
            for value in sensor['values']:
                if 'convert' not in value:
                    continue

                result[value['name']] = {'value': value['convert'](x),
                                         'unit': value.get('unit', None)}

        return result

    {% if test_payloads is defined %}
    if __name__ == '__main__':
        payloads = [
    {%- for pl in test_payloads %}
            '{{pl}}',
    {%- endfor %}
        ]
        for pl in payloads:
            print(json.dumps(decode(pl), indent=True) + "\n")
    {% endif %}